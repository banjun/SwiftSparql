// generated by verbgen

public enum BiboSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://purl.org/ontology/bibo/")}
}

public enum CalSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://www.w3.org/2002/12/cal/icaltzd#")}
}

public enum CcSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://creativecommons.org/ns#")}
}

public enum DcSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://purl.org/dc/elements/1.1/")}
}

public enum DctSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://purl.org/dc/terms/")}
}

public enum DctermsSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://purl.org/dc/terms/")}
}

public enum FoafSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://xmlns.com/foaf/0.1/")}
}

public enum GeoSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://www.w3.org/2003/01/geo/wgs84_pos#")}
}

public enum GeorssSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://www.georss.org/georss")}
}

public enum GrSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://purl.org/goodrelations/v1#")}
}

public enum IcSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://imi.ipa.go.jp/ns/core/rdf#")}
}

public enum JrrkSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://purl.org/jrrk#")}
}

public enum OwlSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://www.w3.org/2002/07/owl#")}
}

public enum PcSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://purl.org/procurement/public-contracts#")}
}

public enum QbSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://purl.org/linked-data/cube#")}
}

public enum RdfSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://www.w3.org/1999/02/22-rdf-syntax-ns#")}
}

public enum RdfsSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://www.w3.org/2000/01/rdf-schema#")}
}

public enum SacSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://statdb.nstac.go.jp/lod/sac/C")}
}

public enum SacsSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://statdb.nstac.go.jp/lod/terms/sacs#")}
}

public enum SchemaSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://schema.org/")}
}

public enum SdmxConceptSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://purl.org/linked-data/sdmx/2009/concept#")}
}

public enum SdmxDimensionSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://purl.org/linked-data/sdmx/2009/dimension#")}
}

public enum SdmxMeasureSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://purl.org/linked-data/sdmx/2009/measure#")}
}

public enum SkosSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://www.w3.org/2004/02/skos/core#")}
}

public enum XsdSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://www.w3.org/2001/XMLSchema#")}
}

public enum RegSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://purl.org/metainfo/terms/registry#")}
}

public enum ImasSchema: IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "https://sparql.crssnky.xyz/imasrdf/URIs/imas-schema.ttl#")}
}

public struct ImasCharacter: RDFTypeConvertible {
    public typealias Schema = ImasSchema
    public static var rdfType: IRIRef {return Schema.rdfType("Character")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasCharacter() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasCharacter>> {return rdfType(is: ImasCharacter.self)}
}

public struct ImasIdol: RDFTypeConvertible {
    public typealias Schema = ImasSchema
    public static var rdfType: IRIRef {return Schema.rdfType("Idol")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasIdol() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasIdol>> {return rdfType(is: ImasIdol.self)}
}

public struct ImasStaff: RDFTypeConvertible {
    public typealias Schema = ImasSchema
    public static var rdfType: IRIRef {return Schema.rdfType("Staff")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasStaff() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasStaff>> {return rdfType(is: ImasStaff.self)}
}

public struct ImasUnit: RDFTypeConvertible {
    public typealias Schema = ImasSchema
    public static var rdfType: IRIRef {return Schema.rdfType("Unit")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasUnit() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasUnit>> {return rdfType(is: ImasUnit.self)}
}

public struct ImasEvent: RDFTypeConvertible {
    public typealias Schema = ImasSchema
    public static var rdfType: IRIRef {return Schema.rdfType("Event")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasEvent() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasEvent>> {return rdfType(is: ImasEvent.self)}
}

public struct ImasFacility: RDFTypeConvertible {
    public typealias Schema = ImasSchema
    public static var rdfType: IRIRef {return Schema.rdfType("Facility")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasFacility() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasFacility>> {return rdfType(is: ImasFacility.self)}
}

public struct ImasCinderellaRankingResult: RDFTypeConvertible {
    public typealias Schema = ImasSchema
    public static var rdfType: IRIRef {return Schema.rdfType("CinderellaRankingResult")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasCinderellaRankingResult() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasCinderellaRankingResult>> {return rdfType(is: ImasCinderellaRankingResult.self)}
}

public struct ImasLive: RDFTypeConvertible {
    public typealias Schema = ImasSchema
    public static var rdfType: IRIRef {return Schema.rdfType("Live")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasLive() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasLive>> {return rdfType(is: ImasLive.self)}
}

public struct ImasSetlistNumber: RDFTypeConvertible {
    public typealias Schema = ImasSchema
    public static var rdfType: IRIRef {return Schema.rdfType("SetlistNumber")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasSetlistNumber() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasSetlistNumber>> {return rdfType(is: ImasSetlistNumber.self)}
}

public struct ImasScriptText: RDFTypeConvertible {
    public typealias Schema = ImasSchema
    public static var rdfType: IRIRef {return Schema.rdfType("ScriptText")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasScriptText() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasScriptText>> {return rdfType(is: ImasScriptText.self)}
}

public struct ImasCommunication: RDFTypeConvertible {
    public typealias Schema = ImasSchema
    public static var rdfType: IRIRef {return Schema.rdfType("Communication")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasCommunication() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasCommunication>> {return rdfType(is: ImasCommunication.self)}
}

public struct ImasCallName: RDFTypeConvertible {
    public typealias Schema = ImasSchema
    public static var rdfType: IRIRef {return Schema.rdfType("CallName")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasCallName() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasCallName>> {return rdfType(is: ImasCallName.self)}
}

public struct ImasIntroduction: RDFTypeConvertible {
    public typealias Schema = ImasSchema
    public static var rdfType: IRIRef {return Schema.rdfType("Introduction")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasIntroduction() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasIntroduction>> {return rdfType(is: ImasIntroduction.self)}
}

public struct ImasClothes: RDFTypeConvertible {
    public typealias Schema = ImasSchema
    public static var rdfType: IRIRef {return Schema.rdfType("Clothes")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasClothes() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasClothes>> {return rdfType(is: ImasClothes.self)}
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasCharacter {
    
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasIdol {
    /// owns: Products owned by the organization or person.
    func schemaOwns(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("owns"), value: [.varOrTerm(.term(v))])
    }
    
    /// owns: Products owned by the organization or person.
    func schemaOwns(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("owns"), value: [.var(v)])
    }
    
    /// memberOf: An Organization (or ProgramMembership) to which this Person or Organization belongs.
    func schemaMemberOf(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("memberOf"), value: [.varOrTerm(.term(v))])
    }
    
    /// memberOf: An Organization (or ProgramMembership) to which this Person or Organization belongs.
    func schemaMemberOf(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("memberOf"), value: [.var(v)])
    }
    
    /// familyName: Family name. In the U.S., the last name of an Person. This can be used along with givenName instead of the name property.
    func schemaFamilyName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("familyName"), value: [.varOrTerm(.term(v))])
    }
    
    /// familyName: Family name. In the U.S., the last name of an Person. This can be used along with givenName instead of the name property.
    func schemaFamilyName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("familyName"), value: [.var(v)])
    }
    
    /// 所属コンテンツ: 所属コンテンツを表すプロパティ
    func imasTitle(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Title"), value: [.varOrTerm(.term(v))])
    }
    
    /// 所属コンテンツ: 所属コンテンツを表すプロパティ
    func imasTitle(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Title"), value: [.var(v)])
    }
    
    /// 姓よみがな: 姓のよみがなを表すプロパティ
    func imasFamilyNameKana(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("familyNameKana"), value: [.varOrTerm(.term(v))])
    }
    
    /// 姓よみがな: 姓のよみがなを表すプロパティ
    func imasFamilyNameKana(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("familyNameKana"), value: [.var(v)])
    }
    
    /// タイプ: タイプ(Cu,Co,Pa)を表すプロパティ
    func imasType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Type"), value: [.varOrTerm(.term(v))])
    }
    
    /// タイプ: タイプ(Cu,Co,Pa)を表すプロパティ
    func imasType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Type"), value: [.var(v)])
    }
    
    /// 趣味: 趣味を表すプロパティ
    func imasHobby(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hobby"), value: [.varOrTerm(.term(v))])
    }
    
    /// 趣味: 趣味を表すプロパティ
    func imasHobby(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hobby"), value: [.var(v)])
    }
    
    /// 担当声優: 担当声優を表すプロパティ
    func imasCv(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("cv"), value: [.varOrTerm(.term(v))])
    }
    
    /// 担当声優: 担当声優を表すプロパティ
    func imasCv(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("cv"), value: [.var(v)])
    }
    
    /// 胸囲: 胸囲を表すプロパティ
    func imasBust(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Bust"), value: [.varOrTerm(.term(v))])
    }
    
    /// 胸囲: 胸囲を表すプロパティ
    func imasBust(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Bust"), value: [.var(v)])
    }
    
    /// 臀囲: 臀囲(尻囲)を表すプロパティ
    func imasHip(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hip"), value: [.varOrTerm(.term(v))])
    }
    
    /// 臀囲: 臀囲(尻囲)を表すプロパティ
    func imasHip(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hip"), value: [.var(v)])
    }
    
    /// birthDate: Date of birth.
    func schemaBirthDate(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("birthDate"), value: [.varOrTerm(.term(v))])
    }
    
    /// birthDate: Date of birth.
    func schemaBirthDate(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("birthDate"), value: [.var(v)])
    }
    
    /// height: The height of the item.
    func schemaHeight(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("height"), value: [.varOrTerm(.term(v))])
    }
    
    /// height: The height of the item.
    func schemaHeight(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("height"), value: [.var(v)])
    }
    
    /// age: The age in years of some agent.
    func foafAge(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: FoafSchema.verb("age"), value: [.varOrTerm(.term(v))])
    }
    
    /// age: The age in years of some agent.
    func foafAge(is v: Var) -> TripleBuilder<State> {
        return appended(verb: FoafSchema.verb("age"), value: [.var(v)])
    }
    
    /// イメージカラー: イメージカラーを表すプロパティ
    func imasColor(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Color"), value: [.varOrTerm(.term(v))])
    }
    
    /// イメージカラー: イメージカラーを表すプロパティ
    func imasColor(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Color"), value: [.var(v)])
    }
    
    /// 血液型: 血液型を表すプロパティ
    func imasBloodType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("BloodType"), value: [.varOrTerm(.term(v))])
    }
    
    /// 血液型: 血液型を表すプロパティ
    func imasBloodType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("BloodType"), value: [.var(v)])
    }
    
    /// 腹囲: 腹囲を表すプロパティ
    func imasWaist(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Waist"), value: [.varOrTerm(.term(v))])
    }
    
    /// 腹囲: 腹囲を表すプロパティ
    func imasWaist(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Waist"), value: [.var(v)])
    }
    
    /// 聞き手: 聞き手を表すプロパティ
    func imasHandedness(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Handedness"), value: [.varOrTerm(.term(v))])
    }
    
    /// 聞き手: 聞き手を表すプロパティ
    func imasHandedness(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Handedness"), value: [.var(v)])
    }
    
    /// birthPlace: The place where the person was born.
    func schemaBirthPlace(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("birthPlace"), value: [.varOrTerm(.term(v))])
    }
    
    /// birthPlace: The place where the person was born.
    func schemaBirthPlace(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("birthPlace"), value: [.var(v)])
    }
    
    /// givenName: Given name. In the U.S., the first name of a Person. This can be used along with familyName instead of the name property.
    func schemaGivenName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("givenName"), value: [.varOrTerm(.term(v))])
    }
    
    /// givenName: Given name. In the U.S., the first name of a Person. This can be used along with familyName instead of the name property.
    func schemaGivenName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("givenName"), value: [.var(v)])
    }
    
    /// 星座: 星座を表すプロパティ
    func imasConstellation(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Constellation"), value: [.varOrTerm(.term(v))])
    }
    
    /// 星座: 星座を表すプロパティ
    func imasConstellation(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Constellation"), value: [.var(v)])
    }
    
    /// 
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// 
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// weight: The weight of the product or person.
    func schemaWeight(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("weight"), value: [.varOrTerm(.term(v))])
    }
    
    /// weight: The weight of the product or person.
    func schemaWeight(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("weight"), value: [.var(v)])
    }
    
    /// 名前よみがな: 名前のよみがなを表すプロパティ
    func imasNameKana(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("nameKana"), value: [.varOrTerm(.term(v))])
    }
    
    /// 名前よみがな: 名前のよみがなを表すプロパティ
    func imasNameKana(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("nameKana"), value: [.var(v)])
    }
    
    /// name: The name of the item.
    func schemaName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.varOrTerm(.term(v))])
    }
    
    /// name: The name of the item.
    func schemaName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.var(v)])
    }
    
    /// gender: Gender of the person. While http://schema.org/Male and http://schema.org/Female may be used, text strings are also acceptable for people who do not identify as a binary gender.
    func schemaGender(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("gender"), value: [.varOrTerm(.term(v))])
    }
    
    /// gender: Gender of the person. While http://schema.org/Male and http://schema.org/Female may be used, text strings are also acceptable for people who do not identify as a binary gender.
    func schemaGender(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("gender"), value: [.var(v)])
    }
    
    /// 名よみがな: 名のよみがなを表すプロパティ
    func imasGivenNameKana(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("givenNameKana"), value: [.varOrTerm(.term(v))])
    }
    
    /// 名よみがな: 名のよみがなを表すプロパティ
    func imasGivenNameKana(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("givenNameKana"), value: [.var(v)])
    }
    
    /// 属性: 属性(Vo,Da,Vi)を表すプロパティ
    func imasAttribute(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Attribute"), value: [.varOrTerm(.term(v))])
    }
    
    /// 属性: 属性(Vo,Da,Vi)を表すプロパティ
    func imasAttribute(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Attribute"), value: [.var(v)])
    }
    
    /// 特技: 特技を表すプロパティ
    func imasTalent(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Talent"), value: [.varOrTerm(.term(v))])
    }
    
    /// 特技: 特技を表すプロパティ
    func imasTalent(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Talent"), value: [.var(v)])
    }
    
    /// 好きなもの: 好きなものを表すプロパティ
    func imasFavorite(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Favorite"), value: [.varOrTerm(.term(v))])
    }
    
    /// 好きなもの: 好きなものを表すプロパティ
    func imasFavorite(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Favorite"), value: [.var(v)])
    }
    
    /// 区分: 区分(Princess・Fairy・Angel)を表すプロパティ
    func imasDivision(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Division"), value: [.varOrTerm(.term(v))])
    }
    
    /// 区分: 区分(Princess・Fairy・Angel)を表すプロパティ
    func imasDivision(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Division"), value: [.var(v)])
    }
    
    /// description: A description of the item.
    func schemaDescription(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("description"), value: [.varOrTerm(.term(v))])
    }
    
    /// description: A description of the item.
    func schemaDescription(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("description"), value: [.var(v)])
    }
    
    /// カテゴリ: カテゴリ(メンタル・フィジカル・インテリ)を表すプロパティ
    func imasCategory(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Category"), value: [.varOrTerm(.term(v))])
    }
    
    /// カテゴリ: カテゴリ(メンタル・フィジカル・インテリ)を表すプロパティ
    func imasCategory(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Category"), value: [.var(v)])
    }
    
    /// 靴のサイズ: 靴のサイズを表すプロパティ
    func imasShoeSize(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("ShoeSize"), value: [.varOrTerm(.term(v))])
    }
    
    /// 靴のサイズ: 靴のサイズを表すプロパティ
    func imasShoeSize(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("ShoeSize"), value: [.var(v)])
    }
    
    /// 通称よみがな: 通称のよみがなを表すプロパティ
    func imasAlternateNameKana(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("alternateNameKana"), value: [.varOrTerm(.term(v))])
    }
    
    /// 通称よみがな: 通称のよみがなを表すプロパティ
    func imasAlternateNameKana(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("alternateNameKana"), value: [.var(v)])
    }
    
    /// alternateName: An alias for the item.
    func schemaAlternateName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("alternateName"), value: [.varOrTerm(.term(v))])
    }
    
    /// alternateName: An alias for the item.
    func schemaAlternateName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("alternateName"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasStaff {
    /// 
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// 
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// age: The age in years of some agent.
    func foafAge(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: FoafSchema.verb("age"), value: [.varOrTerm(.term(v))])
    }
    
    /// age: The age in years of some agent.
    func foafAge(is v: Var) -> TripleBuilder<State> {
        return appended(verb: FoafSchema.verb("age"), value: [.var(v)])
    }
    
    /// 名よみがな: 名のよみがなを表すプロパティ
    func imasGivenNameKana(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("givenNameKana"), value: [.varOrTerm(.term(v))])
    }
    
    /// 名よみがな: 名のよみがなを表すプロパティ
    func imasGivenNameKana(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("givenNameKana"), value: [.var(v)])
    }
    
    /// familyName: Family name. In the U.S., the last name of an Person. This can be used along with givenName instead of the name property.
    func schemaFamilyName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("familyName"), value: [.varOrTerm(.term(v))])
    }
    
    /// familyName: Family name. In the U.S., the last name of an Person. This can be used along with givenName instead of the name property.
    func schemaFamilyName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("familyName"), value: [.var(v)])
    }
    
    /// 名前よみがな: 名前のよみがなを表すプロパティ
    func imasNameKana(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("nameKana"), value: [.varOrTerm(.term(v))])
    }
    
    /// 名前よみがな: 名前のよみがなを表すプロパティ
    func imasNameKana(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("nameKana"), value: [.var(v)])
    }
    
    /// 担当声優: 担当声優を表すプロパティ
    func imasCv(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("cv"), value: [.varOrTerm(.term(v))])
    }
    
    /// 担当声優: 担当声優を表すプロパティ
    func imasCv(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("cv"), value: [.var(v)])
    }
    
    /// 姓よみがな: 姓のよみがなを表すプロパティ
    func imasFamilyNameKana(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("familyNameKana"), value: [.varOrTerm(.term(v))])
    }
    
    /// 姓よみがな: 姓のよみがなを表すプロパティ
    func imasFamilyNameKana(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("familyNameKana"), value: [.var(v)])
    }
    
    /// givenName: Given name. In the U.S., the first name of a Person. This can be used along with familyName instead of the name property.
    func schemaGivenName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("givenName"), value: [.varOrTerm(.term(v))])
    }
    
    /// givenName: Given name. In the U.S., the first name of a Person. This can be used along with familyName instead of the name property.
    func schemaGivenName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("givenName"), value: [.var(v)])
    }
    
    /// position: The position of an item in a series or sequence of items.
    func schemaPosition(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("position"), value: [.varOrTerm(.term(v))])
    }
    
    /// position: The position of an item in a series or sequence of items.
    func schemaPosition(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("position"), value: [.var(v)])
    }
    
    /// name: The name of the item.
    func schemaName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.varOrTerm(.term(v))])
    }
    
    /// name: The name of the item.
    func schemaName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.var(v)])
    }
    
    /// memberOf: An Organization (or ProgramMembership) to which this Person or Organization belongs.
    func schemaMemberOf(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("memberOf"), value: [.varOrTerm(.term(v))])
    }
    
    /// memberOf: An Organization (or ProgramMembership) to which this Person or Organization belongs.
    func schemaMemberOf(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("memberOf"), value: [.var(v)])
    }
    
    /// gender: Gender of the person. While http://schema.org/Male and http://schema.org/Female may be used, text strings are also acceptable for people who do not identify as a binary gender.
    func schemaGender(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("gender"), value: [.varOrTerm(.term(v))])
    }
    
    /// gender: Gender of the person. While http://schema.org/Male and http://schema.org/Female may be used, text strings are also acceptable for people who do not identify as a binary gender.
    func schemaGender(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("gender"), value: [.var(v)])
    }
    
    /// weight: The weight of the product or person.
    func schemaWeight(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("weight"), value: [.varOrTerm(.term(v))])
    }
    
    /// weight: The weight of the product or person.
    func schemaWeight(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("weight"), value: [.var(v)])
    }
    
    /// 血液型: 血液型を表すプロパティ
    func imasBloodType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("BloodType"), value: [.varOrTerm(.term(v))])
    }
    
    /// 血液型: 血液型を表すプロパティ
    func imasBloodType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("BloodType"), value: [.var(v)])
    }
    
    /// height: The height of the item.
    func schemaHeight(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("height"), value: [.varOrTerm(.term(v))])
    }
    
    /// height: The height of the item.
    func schemaHeight(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("height"), value: [.var(v)])
    }
    
    /// 星座: 星座を表すプロパティ
    func imasConstellation(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Constellation"), value: [.varOrTerm(.term(v))])
    }
    
    /// 星座: 星座を表すプロパティ
    func imasConstellation(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Constellation"), value: [.var(v)])
    }
    
    /// birthDate: Date of birth.
    func schemaBirthDate(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("birthDate"), value: [.varOrTerm(.term(v))])
    }
    
    /// birthDate: Date of birth.
    func schemaBirthDate(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("birthDate"), value: [.var(v)])
    }
    
    /// 趣味: 趣味を表すプロパティ
    func imasHobby(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hobby"), value: [.varOrTerm(.term(v))])
    }
    
    /// 趣味: 趣味を表すプロパティ
    func imasHobby(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hobby"), value: [.var(v)])
    }
    
    /// birthPlace: The place where the person was born.
    func schemaBirthPlace(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("birthPlace"), value: [.varOrTerm(.term(v))])
    }
    
    /// birthPlace: The place where the person was born.
    func schemaBirthPlace(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("birthPlace"), value: [.var(v)])
    }
    
    /// alternateName: An alias for the item.
    func schemaAlternateName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("alternateName"), value: [.varOrTerm(.term(v))])
    }
    
    /// alternateName: An alias for the item.
    func schemaAlternateName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("alternateName"), value: [.var(v)])
    }
    
    /// タイプ: タイプ(Cu,Co,Pa)を表すプロパティ
    func imasType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Type"), value: [.varOrTerm(.term(v))])
    }
    
    /// タイプ: タイプ(Cu,Co,Pa)を表すプロパティ
    func imasType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Type"), value: [.var(v)])
    }
    
    /// 胸囲: 胸囲を表すプロパティ
    func imasBust(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Bust"), value: [.varOrTerm(.term(v))])
    }
    
    /// 胸囲: 胸囲を表すプロパティ
    func imasBust(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Bust"), value: [.var(v)])
    }
    
    /// 聞き手: 聞き手を表すプロパティ
    func imasHandedness(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Handedness"), value: [.varOrTerm(.term(v))])
    }
    
    /// 聞き手: 聞き手を表すプロパティ
    func imasHandedness(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Handedness"), value: [.var(v)])
    }
    
    /// 腹囲: 腹囲を表すプロパティ
    func imasWaist(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Waist"), value: [.varOrTerm(.term(v))])
    }
    
    /// 腹囲: 腹囲を表すプロパティ
    func imasWaist(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Waist"), value: [.var(v)])
    }
    
    /// 臀囲: 臀囲(尻囲)を表すプロパティ
    func imasHip(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hip"), value: [.varOrTerm(.term(v))])
    }
    
    /// 臀囲: 臀囲(尻囲)を表すプロパティ
    func imasHip(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hip"), value: [.var(v)])
    }
    
    /// 好きなもの: 好きなものを表すプロパティ
    func imasFavorite(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Favorite"), value: [.varOrTerm(.term(v))])
    }
    
    /// 好きなもの: 好きなものを表すプロパティ
    func imasFavorite(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Favorite"), value: [.var(v)])
    }
    
    /// 特技: 特技を表すプロパティ
    func imasTalent(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Talent"), value: [.varOrTerm(.term(v))])
    }
    
    /// 特技: 特技を表すプロパティ
    func imasTalent(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Talent"), value: [.var(v)])
    }
    
    /// イメージカラー: イメージカラーを表すプロパティ
    func imasColor(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Color"), value: [.varOrTerm(.term(v))])
    }
    
    /// イメージカラー: イメージカラーを表すプロパティ
    func imasColor(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Color"), value: [.var(v)])
    }
    
    /// 靴のサイズ: 靴のサイズを表すプロパティ
    func imasShoeSize(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("ShoeSize"), value: [.varOrTerm(.term(v))])
    }
    
    /// 靴のサイズ: 靴のサイズを表すプロパティ
    func imasShoeSize(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("ShoeSize"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasUnit {
    /// name: The name of the item.
    func schemaName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.varOrTerm(.term(v))])
    }
    
    /// name: The name of the item.
    func schemaName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.var(v)])
    }
    
    /// member: A member of an Organization or a ProgramMembership. Organizations can be members of organizations; ProgramMembership is typically for individuals.
    func schemaMember(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("member"), value: [.varOrTerm(.term(v))])
    }
    
    /// member: A member of an Organization or a ProgramMembership. Organizations can be members of organizations; ProgramMembership is typically for individuals.
    func schemaMember(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("member"), value: [.var(v)])
    }
    
    /// 
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// 
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// alternateName: An alias for the item.
    func schemaAlternateName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("alternateName"), value: [.varOrTerm(.term(v))])
    }
    
    /// alternateName: An alias for the item.
    func schemaAlternateName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("alternateName"), value: [.var(v)])
    }
    
    /// イメージカラー: イメージカラーを表すプロパティ
    func imasColor(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Color"), value: [.varOrTerm(.term(v))])
    }
    
    /// イメージカラー: イメージカラーを表すプロパティ
    func imasColor(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Color"), value: [.var(v)])
    }
    
    /// description: A description of the item.
    func schemaDescription(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("description"), value: [.varOrTerm(.term(v))])
    }
    
    /// description: A description of the item.
    func schemaDescription(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("description"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasEvent {
    /// name: The name of the item.
    func schemaName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.varOrTerm(.term(v))])
    }
    
    /// name: The name of the item.
    func schemaName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.var(v)])
    }
    
    /// actor: An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
    func schemaActor(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("actor"), value: [.varOrTerm(.term(v))])
    }
    
    /// actor: An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
    func schemaActor(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("actor"), value: [.var(v)])
    }
    
    /// 
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// 
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasFacility {
    
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasCinderellaRankingResult {
    /// member: A member of an Organization or a ProgramMembership. Organizations can be members of organizations; ProgramMembership is typically for individuals.
    func schemaMember(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("member"), value: [.varOrTerm(.term(v))])
    }
    
    /// member: A member of an Organization or a ProgramMembership. Organizations can be members of organizations; ProgramMembership is typically for individuals.
    func schemaMember(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("member"), value: [.var(v)])
    }
    
    /// 
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// 
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// 得票数: 得票数を表すプロパティ
    func imasVoteNumber(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("VoteNumber"), value: [.varOrTerm(.term(v))])
    }
    
    /// 得票数: 得票数を表すプロパティ
    func imasVoteNumber(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("VoteNumber"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasLive {
    /// actor: An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
    func schemaActor(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("actor"), value: [.varOrTerm(.term(v))])
    }
    
    /// actor: An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
    func schemaActor(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("actor"), value: [.var(v)])
    }
    
    /// name: The name of the item.
    func schemaName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.varOrTerm(.term(v))])
    }
    
    /// name: The name of the item.
    func schemaName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.var(v)])
    }
    
    /// location: The location of for example where the event is happening, an organization is located, or where an action takes place.
    func schemaLocation(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("location"), value: [.varOrTerm(.term(v))])
    }
    
    /// location: The location of for example where the event is happening, an organization is located, or where an action takes place.
    func schemaLocation(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("location"), value: [.var(v)])
    }
    
    /// startDate: The start date and time of the item (in <a href=\"http://en.wikipedia.org/wiki/ISO_8601\">ISO 8601 date format</a>).
    func schemaStartDate(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("startDate"), value: [.varOrTerm(.term(v))])
    }
    
    /// startDate: The start date and time of the item (in <a href=\"http://en.wikipedia.org/wiki/ISO_8601\">ISO 8601 date format</a>).
    func schemaStartDate(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("startDate"), value: [.var(v)])
    }
    
    /// endDate: The end date and time of the item (in <a href=\"http://en.wikipedia.org/wiki/ISO_8601\">ISO 8601 date format</a>).
    func schemaEndDate(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("endDate"), value: [.varOrTerm(.term(v))])
    }
    
    /// endDate: The end date and time of the item (in <a href=\"http://en.wikipedia.org/wiki/ISO_8601\">ISO 8601 date format</a>).
    func schemaEndDate(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("endDate"), value: [.var(v)])
    }
    
    /// 披露した曲: 披露した曲を表すプロパティ
    func imasPerformance(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Performance"), value: [.varOrTerm(.term(v))])
    }
    
    /// 披露した曲: 披露した曲を表すプロパティ
    func imasPerformance(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Performance"), value: [.var(v)])
    }
    
    /// 披露した曲数: 披露した曲数を表すプロパティ
    func imasNumPerformance(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("NumPerformance"), value: [.varOrTerm(.term(v))])
    }
    
    /// 披露した曲数: 披露した曲数を表すプロパティ
    func imasNumPerformance(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("NumPerformance"), value: [.var(v)])
    }
    
    /// 
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// 
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// 披露したアンコール曲数: 披露したアンコール曲数を表すプロパティ
    func imasNumPerformanceEncore(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("NumPerformanceEncore"), value: [.varOrTerm(.term(v))])
    }
    
    /// 披露したアンコール曲数: 披露したアンコール曲数を表すプロパティ
    func imasNumPerformanceEncore(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("NumPerformanceEncore"), value: [.var(v)])
    }
    
    /// url: URL of the item.
    func schemaUrl(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("url"), value: [.varOrTerm(.term(v))])
    }
    
    /// url: URL of the item.
    func schemaUrl(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("url"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasSetlistNumber {
    /// セットリスト内番号: セットリスト内番号を表すプロパティ
    func imasTuneNumber(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("TuneNumber"), value: [.varOrTerm(.term(v))])
    }
    
    /// セットリスト内番号: セットリスト内番号を表すプロパティ
    func imasTuneNumber(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("TuneNumber"), value: [.var(v)])
    }
    
    /// actor: An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
    func schemaActor(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("actor"), value: [.varOrTerm(.term(v))])
    }
    
    /// actor: An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
    func schemaActor(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("actor"), value: [.var(v)])
    }
    
    /// name: The name of the item.
    func schemaName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.varOrTerm(.term(v))])
    }
    
    /// name: The name of the item.
    func schemaName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.var(v)])
    }
    
    /// 
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// 
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// performer: A performer at the event&#x2014;for example, a presenter, musician, musical group or actor.
    func schemaPerformer(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("performer"), value: [.varOrTerm(.term(v))])
    }
    
    /// performer: A performer at the event&#x2014;for example, a presenter, musician, musical group or actor.
    func schemaPerformer(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("performer"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasScriptText {
    /// 出どころ: 出どころを表すプロパティ
    func imasSource(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Source"), value: [.varOrTerm(.term(v))])
    }
    
    /// 出どころ: 出どころを表すプロパティ
    func imasSource(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Source"), value: [.var(v)])
    }
    
    /// 発言者表記: 発言者表記を表すプロパティ
    func imasSpeakerLabel(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("SpeakerLabel"), value: [.varOrTerm(.term(v))])
    }
    
    /// 発言者表記: 発言者表記を表すプロパティ
    func imasSpeakerLabel(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("SpeakerLabel"), value: [.var(v)])
    }
    
    /// text: The textual content of this CreativeWork.
    func schemaText(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("text"), value: [.varOrTerm(.term(v))])
    }
    
    /// text: The textual content of this CreativeWork.
    func schemaText(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("text"), value: [.var(v)])
    }
    
    /// セリフテキスト番号: セリフテキスト番号を表すプロパティ
    func imasScriptNumber(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("ScriptNumber"), value: [.varOrTerm(.term(v))])
    }
    
    /// セリフテキスト番号: セリフテキスト番号を表すプロパティ
    func imasScriptNumber(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("ScriptNumber"), value: [.var(v)])
    }
    
    /// 
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// 
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasCommunication {
    /// セリフテキスト: セリフテキストを表すプロパティ
    func imasScript(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Script"), value: [.varOrTerm(.term(v))])
    }
    
    /// セリフテキスト: セリフテキストを表すプロパティ
    func imasScript(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Script"), value: [.var(v)])
    }
    
    /// participant: Other co-agents that participated in the action indirectly. e.g. John wrote a book with <em>Steve</em>.
    func schemaParticipant(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("participant"), value: [.varOrTerm(.term(v))])
    }
    
    /// participant: Other co-agents that participated in the action indirectly. e.g. John wrote a book with <em>Steve</em>.
    func schemaParticipant(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("participant"), value: [.var(v)])
    }
    
    /// 
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// 
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// title: The title of the job.
    func schemaTitle(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("title"), value: [.varOrTerm(.term(v))])
    }
    
    /// title: The title of the job.
    func schemaTitle(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("title"), value: [.var(v)])
    }
    
    /// location: The location of for example where the event is happening, an organization is located, or where an action takes place.
    func schemaLocation(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("location"), value: [.varOrTerm(.term(v))])
    }
    
    /// location: The location of for example where the event is happening, an organization is located, or where an action takes place.
    func schemaLocation(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("location"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasCallName {
    /// 出どころ: 出どころを表すプロパティ
    func imasSource(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Source"), value: [.varOrTerm(.term(v))])
    }
    
    /// 出どころ: 出どころを表すプロパティ
    func imasSource(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Source"), value: [.var(v)])
    }
    
    /// あて先: あて先を表すプロパティ
    func imasDestination(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Destination"), value: [.varOrTerm(.term(v))])
    }
    
    /// あて先: あて先を表すプロパティ
    func imasDestination(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Destination"), value: [.var(v)])
    }
    
    /// 呼び方: 呼び方を表すプロパティ
    func imasCalled(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Called"), value: [.varOrTerm(.term(v))])
    }
    
    /// 呼び方: 呼び方を表すプロパティ
    func imasCalled(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Called"), value: [.var(v)])
    }
    
    /// 
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// 
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasIntroduction {
    /// あて先: あて先を表すプロパティ
    func imasDestination(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Destination"), value: [.varOrTerm(.term(v))])
    }
    
    /// あて先: あて先を表すプロパティ
    func imasDestination(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Destination"), value: [.var(v)])
    }
    
    /// 出どころ: 出どころを表すプロパティ
    func imasSource(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Source"), value: [.varOrTerm(.term(v))])
    }
    
    /// 出どころ: 出どころを表すプロパティ
    func imasSource(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Source"), value: [.var(v)])
    }
    
    /// 
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// 
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// name: The name of the item.
    func schemaName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.varOrTerm(.term(v))])
    }
    
    /// name: The name of the item.
    func schemaName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.var(v)])
    }
    
    /// description: A description of the item.
    func schemaDescription(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("description"), value: [.varOrTerm(.term(v))])
    }
    
    /// description: A description of the item.
    func schemaDescription(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("description"), value: [.var(v)])
    }
    
    /// releaseDate: The release date of a product or product model. This can be used to distinguish the exact variant of a product.
    func schemaReleaseDate(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("releaseDate"), value: [.varOrTerm(.term(v))])
    }
    
    /// releaseDate: The release date of a product or product model. This can be used to distinguish the exact variant of a product.
    func schemaReleaseDate(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("releaseDate"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasClothes {
    /// name: The name of the item.
    func schemaName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.varOrTerm(.term(v))])
    }
    
    /// name: The name of the item.
    func schemaName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.var(v)])
    }
    
    /// description: A description of the item.
    func schemaDescription(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("description"), value: [.varOrTerm(.term(v))])
    }
    
    /// description: A description of the item.
    func schemaDescription(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("description"), value: [.var(v)])
    }
    
    /// 所有者: 所有者を表すプロパティ
    func imasWhose(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Whose"), value: [.varOrTerm(.term(v))])
    }
    
    /// 所有者: 所有者を表すプロパティ
    func imasWhose(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Whose"), value: [.var(v)])
    }
    
    /// 
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// 
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
}