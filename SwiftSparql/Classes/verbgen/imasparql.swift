// generated by verbgen

fileprivate enum DctermsSchema: IRIBaseProvider {
    static var base: IRIRef {return IRIRef(value: "http://purl.org/dc/terms/")}
}

fileprivate enum FoafSchema: IRIBaseProvider {
    static var base: IRIRef {return IRIRef(value: "http://xmlns.com/foaf/0.1/")}
}

fileprivate enum OwlSchema: IRIBaseProvider {
    static var base: IRIRef {return IRIRef(value: "http://www.w3.org/2002/07/owl#")}
}

fileprivate enum RdfSchema: IRIBaseProvider {
    static var base: IRIRef {return IRIRef(value: "http://www.w3.org/1999/02/22-rdf-syntax-ns#")}
}

fileprivate enum RdfsSchema: IRIBaseProvider {
    static var base: IRIRef {return IRIRef(value: "http://www.w3.org/2000/01/rdf-schema#")}
}

fileprivate enum SchemaSchema: IRIBaseProvider {
    static var base: IRIRef {return IRIRef(value: "http://schema.org/")}
}

fileprivate enum ImasSchema: IRIBaseProvider {
    static var base: IRIRef {return IRIRef(value: "https://sparql.crssnky.xyz/imasrdf/URIs/imas-schema.ttl#")}
}

public struct ImasCharacter: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("Character")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasCharacter() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasCharacter>> {return rdfType(is: ImasCharacter.self)}
}

public struct ImasIdol: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("Idol")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasIdol() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasIdol>> {return rdfType(is: ImasIdol.self)}
}

public struct ImasIdol_1st: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("Idol_1st")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasIdol_1st() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasIdol_1st>> {return rdfType(is: ImasIdol_1st.self)}
}

public struct ImasStaff: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("Staff")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasStaff() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasStaff>> {return rdfType(is: ImasStaff.self)}
}

public struct ImasXenoglossiaIdol: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("XenoglossiaIdol")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasXenoglossiaIdol() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasXenoglossiaIdol>> {return rdfType(is: ImasXenoglossiaIdol.self)}
}

public struct ImasXenoglossiaCharacter: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("XenoglossiaCharacter")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasXenoglossiaCharacter() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasXenoglossiaCharacter>> {return rdfType(is: ImasXenoglossiaCharacter.self)}
}

public struct ImasUnit: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("Unit")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasUnit() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasUnit>> {return rdfType(is: ImasUnit.self)}
}

public struct ImasEvent: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("Event")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasEvent() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasEvent>> {return rdfType(is: ImasEvent.self)}
}

public struct ImasFacility: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("Facility")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasFacility() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasFacility>> {return rdfType(is: ImasFacility.self)}
}

public struct ImasProduction: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("Production")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasProduction() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasProduction>> {return rdfType(is: ImasProduction.self)}
}

public struct ImasCinderellaRankingResult: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("CinderellaRankingResult")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasCinderellaRankingResult() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasCinderellaRankingResult>> {return rdfType(is: ImasCinderellaRankingResult.self)}
}

public struct ImasCinderellaVoiceIdolAudition: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("CinderellaVoiceIdolAudition")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasCinderellaVoiceIdolAudition() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasCinderellaVoiceIdolAudition>> {return rdfType(is: ImasCinderellaVoiceIdolAudition.self)}
}

public struct ImasLive: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("Live")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasLive() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasLive>> {return rdfType(is: ImasLive.self)}
}

public struct ImasSetlistNumber: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("SetlistNumber")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasSetlistNumber() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasSetlistNumber>> {return rdfType(is: ImasSetlistNumber.self)}
}

public struct ImasScriptText: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("ScriptText")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasScriptText() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasScriptText>> {return rdfType(is: ImasScriptText.self)}
}

public struct ImasCommunication: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("Communication")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasCommunication() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasCommunication>> {return rdfType(is: ImasCommunication.self)}
}

public struct ImasCallName: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("CallName")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasCallName() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasCallName>> {return rdfType(is: ImasCallName.self)}
}

public struct ImasIntroduction: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("Introduction")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasIntroduction() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasIntroduction>> {return rdfType(is: ImasIntroduction.self)}
}

public struct ImasClothes: RDFTypeConvertible {
    public static var rdfType: IRIRef {return ImasSchema.rdfType("Clothes")}
}

extension TripleBuilder where State: TripleBuilderStateIncompleteSubjectType {
    public func rdfTypeIsImasClothes() -> TripleBuilder<TripleBuilderStateRDFTypeBound<ImasClothes>> {return rdfType(is: ImasClothes.self)}
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasCharacter {
    
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasIdol {
    /// alternateName: An alias for the item.
    func schemaAlternateName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("alternateName"), value: [.varOrTerm(.term(v))])
    }
    
    /// alternateName: An alias for the item.
    func schemaAlternateName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("alternateName"), value: [.var(v)])
    }
    
    /// birthDate: Date of birth.
    func schemaBirthDate(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("birthDate"), value: [.varOrTerm(.term(v))])
    }
    
    /// birthDate: Date of birth.
    func schemaBirthDate(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("birthDate"), value: [.var(v)])
    }
    
    /// birthPlace: The place where the person was born.
    func schemaBirthPlace(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("birthPlace"), value: [.varOrTerm(.term(v))])
    }
    
    /// birthPlace: The place where the person was born.
    func schemaBirthPlace(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("birthPlace"), value: [.var(v)])
    }
    
    /// description: A description of the item.
    func schemaDescription(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("description"), value: [.varOrTerm(.term(v))])
    }
    
    /// description: A description of the item.
    func schemaDescription(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("description"), value: [.var(v)])
    }
    
    /// familyName: Family name. In the U.S., the last name of a Person.
    func schemaFamilyName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("familyName"), value: [.varOrTerm(.term(v))])
    }
    
    /// familyName: Family name. In the U.S., the last name of a Person.
    func schemaFamilyName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("familyName"), value: [.var(v)])
    }
    
    /// gender: Gender of something, typically a [[Person]], but possibly also fictional characters, animals, etc. While https://schema.org/Male and https://schema.org/Female may be used, text strings are also acceptable for people who do not identify as a binary gender. The [[gender]] property can also be used in an extended sense to cover e.g. the gender of sports teams. As with the gender of individuals, we do not try to enumerate all possibilities. A mixed-gender [[SportsTeam]] can be indicated with a text value of \"Mixed\".
    func schemaGender(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("gender"), value: [.varOrTerm(.term(v))])
    }
    
    /// gender: Gender of something, typically a [[Person]], but possibly also fictional characters, animals, etc. While https://schema.org/Male and https://schema.org/Female may be used, text strings are also acceptable for people who do not identify as a binary gender. The [[gender]] property can also be used in an extended sense to cover e.g. the gender of sports teams. As with the gender of individuals, we do not try to enumerate all possibilities. A mixed-gender [[SportsTeam]] can be indicated with a text value of \"Mixed\".
    func schemaGender(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("gender"), value: [.var(v)])
    }
    
    /// givenName: Given name. In the U.S., the first name of a Person.
    func schemaGivenName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("givenName"), value: [.varOrTerm(.term(v))])
    }
    
    /// givenName: Given name. In the U.S., the first name of a Person.
    func schemaGivenName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("givenName"), value: [.var(v)])
    }
    
    /// height: The height of the item.
    func schemaHeight(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("height"), value: [.varOrTerm(.term(v))])
    }
    
    /// height: The height of the item.
    func schemaHeight(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("height"), value: [.var(v)])
    }
    
    /// memberOf: An Organization (or ProgramMembership) to which this Person or Organization belongs.
    func schemaMemberOf(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("memberOf"), value: [.varOrTerm(.term(v))])
    }
    
    /// memberOf: An Organization (or ProgramMembership) to which this Person or Organization belongs.
    func schemaMemberOf(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("memberOf"), value: [.var(v)])
    }
    
    /// name: The name of the item.
    func schemaName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.varOrTerm(.term(v))])
    }
    
    /// name: The name of the item.
    func schemaName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.var(v)])
    }
    
    /// owns: Products owned by the organization or person.
    func schemaOwns(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("owns"), value: [.varOrTerm(.term(v))])
    }
    
    /// owns: Products owned by the organization or person.
    func schemaOwns(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("owns"), value: [.var(v)])
    }
    
    /// weight: The weight of the product or person.
    func schemaWeight(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("weight"), value: [.varOrTerm(.term(v))])
    }
    
    /// weight: The weight of the product or person.
    func schemaWeight(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("weight"), value: [.var(v)])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// label: A human-readable name for the subject.
    func rdfsLabel(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfsSchema.verb("label"), value: [.varOrTerm(.term(v))])
    }
    
    /// label: A human-readable name for the subject.
    func rdfsLabel(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfsSchema.verb("label"), value: [.var(v)])
    }
    
    /// age: The age in years of some agent.
    func foafAge(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: FoafSchema.verb("age"), value: [.varOrTerm(.term(v))])
    }
    
    /// age: The age in years of some agent.
    func foafAge(is v: Var) -> TripleBuilder<State> {
        return appended(verb: FoafSchema.verb("age"), value: [.var(v)])
    }
    
    /// 属性: 属性(Vo,Da,Vi)を表すプロパティ
    func imasAttribute(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Attribute"), value: [.varOrTerm(.term(v))])
    }
    
    /// 属性: 属性(Vo,Da,Vi)を表すプロパティ
    func imasAttribute(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Attribute"), value: [.var(v)])
    }
    
    /// 血液型: 血液型を表すプロパティ
    func imasBloodType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("BloodType"), value: [.varOrTerm(.term(v))])
    }
    
    /// 血液型: 血液型を表すプロパティ
    func imasBloodType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("BloodType"), value: [.var(v)])
    }
    
    /// 胸囲: 胸囲を表すプロパティ
    func imasBust(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Bust"), value: [.varOrTerm(.term(v))])
    }
    
    /// 胸囲: 胸囲を表すプロパティ
    func imasBust(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Bust"), value: [.var(v)])
    }
    
    /// カテゴリ: カテゴリ(メンタル・フィジカル・インテリ)を表すプロパティ
    func imasCategory(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Category"), value: [.varOrTerm(.term(v))])
    }
    
    /// カテゴリ: カテゴリ(メンタル・フィジカル・インテリ)を表すプロパティ
    func imasCategory(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Category"), value: [.var(v)])
    }
    
    /// イメージカラー: イメージカラーを表すプロパティ
    func imasColor(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Color"), value: [.varOrTerm(.term(v))])
    }
    
    /// イメージカラー: イメージカラーを表すプロパティ
    func imasColor(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Color"), value: [.var(v)])
    }
    
    /// 星座: 星座を表すプロパティ
    func imasConstellation(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Constellation"), value: [.varOrTerm(.term(v))])
    }
    
    /// 星座: 星座を表すプロパティ
    func imasConstellation(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Constellation"), value: [.var(v)])
    }
    
    /// 区分: 区分(Princess・Fairy・Angel)を表すプロパティ
    func imasDivision(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Division"), value: [.varOrTerm(.term(v))])
    }
    
    /// 区分: 区分(Princess・Fairy・Angel)を表すプロパティ
    func imasDivision(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Division"), value: [.var(v)])
    }
    
    /// 好きなもの: 好きなものを表すプロパティ
    func imasFavorite(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Favorite"), value: [.varOrTerm(.term(v))])
    }
    
    /// 好きなもの: 好きなものを表すプロパティ
    func imasFavorite(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Favorite"), value: [.var(v)])
    }
    
    /// 利き手: 利き手を表すプロパティ
    func imasHandedness(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Handedness"), value: [.varOrTerm(.term(v))])
    }
    
    /// 利き手: 利き手を表すプロパティ
    func imasHandedness(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Handedness"), value: [.var(v)])
    }
    
    /// 臀囲: 臀囲(尻囲)を表すプロパティ
    func imasHip(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hip"), value: [.varOrTerm(.term(v))])
    }
    
    /// 臀囲: 臀囲(尻囲)を表すプロパティ
    func imasHip(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hip"), value: [.var(v)])
    }
    
    /// 趣味: 趣味を表すプロパティ
    func imasHobby(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hobby"), value: [.varOrTerm(.term(v))])
    }
    
    /// 趣味: 趣味を表すプロパティ
    func imasHobby(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hobby"), value: [.var(v)])
    }
    
    /// アイドル名鑑URL: アイドル名鑑のアイドル毎URL
    func imasIdolListURL(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("IdolListURL"), value: [.varOrTerm(.term(v))])
    }
    
    /// アイドル名鑑URL: アイドル名鑑のアイドル毎URL
    func imasIdolListURL(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("IdolListURL"), value: [.var(v)])
    }
    
    /// 靴のサイズ: 靴のサイズを表すプロパティ
    func imasShoeSize(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("ShoeSize"), value: [.varOrTerm(.term(v))])
    }
    
    /// 靴のサイズ: 靴のサイズを表すプロパティ
    func imasShoeSize(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("ShoeSize"), value: [.var(v)])
    }
    
    /// 特技: 特技を表すプロパティ
    func imasTalent(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Talent"), value: [.varOrTerm(.term(v))])
    }
    
    /// 特技: 特技を表すプロパティ
    func imasTalent(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Talent"), value: [.var(v)])
    }
    
    /// 所属コンテンツ: 所属コンテンツを表すプロパティ
    func imasTitle(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Title"), value: [.varOrTerm(.term(v))])
    }
    
    /// 所属コンテンツ: 所属コンテンツを表すプロパティ
    func imasTitle(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Title"), value: [.var(v)])
    }
    
    /// タイプ: タイプ(Cu,Co,Pa)を表すプロパティ
    func imasType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Type"), value: [.varOrTerm(.term(v))])
    }
    
    /// タイプ: タイプ(Cu,Co,Pa)を表すプロパティ
    func imasType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Type"), value: [.var(v)])
    }
    
    /// 腹囲: 腹囲を表すプロパティ
    func imasWaist(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Waist"), value: [.varOrTerm(.term(v))])
    }
    
    /// 腹囲: 腹囲を表すプロパティ
    func imasWaist(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Waist"), value: [.var(v)])
    }
    
    /// 通称よみがな: 通称のよみがなを表すプロパティ
    func imasAlternateNameKana(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("alternateNameKana"), value: [.varOrTerm(.term(v))])
    }
    
    /// 通称よみがな: 通称のよみがなを表すプロパティ
    func imasAlternateNameKana(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("alternateNameKana"), value: [.var(v)])
    }
    
    /// 担当声優: 担当声優を表すプロパティ
    func imasCv(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("cv"), value: [.varOrTerm(.term(v))])
    }
    
    /// 担当声優: 担当声優を表すプロパティ
    func imasCv(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("cv"), value: [.var(v)])
    }
    
    /// 姓よみがな: 姓のよみがなを表すプロパティ
    func imasFamilyNameKana(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("familyNameKana"), value: [.varOrTerm(.term(v))])
    }
    
    /// 姓よみがな: 姓のよみがなを表すプロパティ
    func imasFamilyNameKana(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("familyNameKana"), value: [.var(v)])
    }
    
    /// 名よみがな: 名のよみがなを表すプロパティ
    func imasGivenNameKana(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("givenNameKana"), value: [.varOrTerm(.term(v))])
    }
    
    /// 名よみがな: 名のよみがなを表すプロパティ
    func imasGivenNameKana(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("givenNameKana"), value: [.var(v)])
    }
    
    /// 名前よみがな: 名前のよみがなを表すプロパティ
    func imasNameKana(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("nameKana"), value: [.varOrTerm(.term(v))])
    }
    
    /// 名前よみがな: 名前のよみがなを表すプロパティ
    func imasNameKana(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("nameKana"), value: [.var(v)])
    }
    
    /// 過去の担当声優: 過去の担当声優を表すプロパティ
    func imasPastCv(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("pastCv"), value: [.varOrTerm(.term(v))])
    }
    
    /// 過去の担当声優: 過去の担当声優を表すプロパティ
    func imasPastCv(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("pastCv"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasIdol_1st {
    /// birthDate: Date of birth.
    func schemaBirthDate(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("birthDate"), value: [.varOrTerm(.term(v))])
    }
    
    /// birthDate: Date of birth.
    func schemaBirthDate(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("birthDate"), value: [.var(v)])
    }
    
    /// familyName: Family name. In the U.S., the last name of a Person.
    func schemaFamilyName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("familyName"), value: [.varOrTerm(.term(v))])
    }
    
    /// familyName: Family name. In the U.S., the last name of a Person.
    func schemaFamilyName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("familyName"), value: [.var(v)])
    }
    
    /// gender: Gender of something, typically a [[Person]], but possibly also fictional characters, animals, etc. While https://schema.org/Male and https://schema.org/Female may be used, text strings are also acceptable for people who do not identify as a binary gender. The [[gender]] property can also be used in an extended sense to cover e.g. the gender of sports teams. As with the gender of individuals, we do not try to enumerate all possibilities. A mixed-gender [[SportsTeam]] can be indicated with a text value of \"Mixed\".
    func schemaGender(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("gender"), value: [.varOrTerm(.term(v))])
    }
    
    /// gender: Gender of something, typically a [[Person]], but possibly also fictional characters, animals, etc. While https://schema.org/Male and https://schema.org/Female may be used, text strings are also acceptable for people who do not identify as a binary gender. The [[gender]] property can also be used in an extended sense to cover e.g. the gender of sports teams. As with the gender of individuals, we do not try to enumerate all possibilities. A mixed-gender [[SportsTeam]] can be indicated with a text value of \"Mixed\".
    func schemaGender(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("gender"), value: [.var(v)])
    }
    
    /// givenName: Given name. In the U.S., the first name of a Person.
    func schemaGivenName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("givenName"), value: [.varOrTerm(.term(v))])
    }
    
    /// givenName: Given name. In the U.S., the first name of a Person.
    func schemaGivenName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("givenName"), value: [.var(v)])
    }
    
    /// height: The height of the item.
    func schemaHeight(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("height"), value: [.varOrTerm(.term(v))])
    }
    
    /// height: The height of the item.
    func schemaHeight(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("height"), value: [.var(v)])
    }
    
    /// name: The name of the item.
    func schemaName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.varOrTerm(.term(v))])
    }
    
    /// name: The name of the item.
    func schemaName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.var(v)])
    }
    
    /// weight: The weight of the product or person.
    func schemaWeight(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("weight"), value: [.varOrTerm(.term(v))])
    }
    
    /// weight: The weight of the product or person.
    func schemaWeight(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("weight"), value: [.var(v)])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// label: A human-readable name for the subject.
    func rdfsLabel(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfsSchema.verb("label"), value: [.varOrTerm(.term(v))])
    }
    
    /// label: A human-readable name for the subject.
    func rdfsLabel(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfsSchema.verb("label"), value: [.var(v)])
    }
    
    /// age: The age in years of some agent.
    func foafAge(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: FoafSchema.verb("age"), value: [.varOrTerm(.term(v))])
    }
    
    /// age: The age in years of some agent.
    func foafAge(is v: Var) -> TripleBuilder<State> {
        return appended(verb: FoafSchema.verb("age"), value: [.var(v)])
    }
    
    /// 血液型: 血液型を表すプロパティ
    func imasBloodType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("BloodType"), value: [.varOrTerm(.term(v))])
    }
    
    /// 血液型: 血液型を表すプロパティ
    func imasBloodType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("BloodType"), value: [.var(v)])
    }
    
    /// 胸囲: 胸囲を表すプロパティ
    func imasBust(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Bust"), value: [.varOrTerm(.term(v))])
    }
    
    /// 胸囲: 胸囲を表すプロパティ
    func imasBust(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Bust"), value: [.var(v)])
    }
    
    /// イメージカラー: イメージカラーを表すプロパティ
    func imasColor(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Color"), value: [.varOrTerm(.term(v))])
    }
    
    /// イメージカラー: イメージカラーを表すプロパティ
    func imasColor(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Color"), value: [.var(v)])
    }
    
    /// 星座: 星座を表すプロパティ
    func imasConstellation(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Constellation"), value: [.varOrTerm(.term(v))])
    }
    
    /// 星座: 星座を表すプロパティ
    func imasConstellation(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Constellation"), value: [.var(v)])
    }
    
    /// 臀囲: 臀囲(尻囲)を表すプロパティ
    func imasHip(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hip"), value: [.varOrTerm(.term(v))])
    }
    
    /// 臀囲: 臀囲(尻囲)を表すプロパティ
    func imasHip(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hip"), value: [.var(v)])
    }
    
    /// 趣味: 趣味を表すプロパティ
    func imasHobby(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hobby"), value: [.varOrTerm(.term(v))])
    }
    
    /// 趣味: 趣味を表すプロパティ
    func imasHobby(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hobby"), value: [.var(v)])
    }
    
    /// アイドル名鑑URL: アイドル名鑑のアイドル毎URL
    func imasIdolListURL(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("IdolListURL"), value: [.varOrTerm(.term(v))])
    }
    
    /// アイドル名鑑URL: アイドル名鑑のアイドル毎URL
    func imasIdolListURL(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("IdolListURL"), value: [.var(v)])
    }
    
    /// 特技: 特技を表すプロパティ
    func imasTalent(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Talent"), value: [.varOrTerm(.term(v))])
    }
    
    /// 特技: 特技を表すプロパティ
    func imasTalent(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Talent"), value: [.var(v)])
    }
    
    /// 所属コンテンツ: 所属コンテンツを表すプロパティ
    func imasTitle(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Title"), value: [.varOrTerm(.term(v))])
    }
    
    /// 所属コンテンツ: 所属コンテンツを表すプロパティ
    func imasTitle(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Title"), value: [.var(v)])
    }
    
    /// 腹囲: 腹囲を表すプロパティ
    func imasWaist(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Waist"), value: [.varOrTerm(.term(v))])
    }
    
    /// 腹囲: 腹囲を表すプロパティ
    func imasWaist(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Waist"), value: [.var(v)])
    }
    
    /// 担当声優: 担当声優を表すプロパティ
    func imasCv(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("cv"), value: [.varOrTerm(.term(v))])
    }
    
    /// 担当声優: 担当声優を表すプロパティ
    func imasCv(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("cv"), value: [.var(v)])
    }
    
    /// 姓よみがな: 姓のよみがなを表すプロパティ
    func imasFamilyNameKana(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("familyNameKana"), value: [.varOrTerm(.term(v))])
    }
    
    /// 姓よみがな: 姓のよみがなを表すプロパティ
    func imasFamilyNameKana(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("familyNameKana"), value: [.var(v)])
    }
    
    /// 名よみがな: 名のよみがなを表すプロパティ
    func imasGivenNameKana(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("givenNameKana"), value: [.varOrTerm(.term(v))])
    }
    
    /// 名よみがな: 名のよみがなを表すプロパティ
    func imasGivenNameKana(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("givenNameKana"), value: [.var(v)])
    }
    
    /// 名前よみがな: 名前のよみがなを表すプロパティ
    func imasNameKana(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("nameKana"), value: [.varOrTerm(.term(v))])
    }
    
    /// 名前よみがな: 名前のよみがなを表すプロパティ
    func imasNameKana(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("nameKana"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasStaff {
    /// alternateName: An alias for the item.
    func schemaAlternateName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("alternateName"), value: [.varOrTerm(.term(v))])
    }
    
    /// alternateName: An alias for the item.
    func schemaAlternateName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("alternateName"), value: [.var(v)])
    }
    
    /// birthDate: Date of birth.
    func schemaBirthDate(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("birthDate"), value: [.varOrTerm(.term(v))])
    }
    
    /// birthDate: Date of birth.
    func schemaBirthDate(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("birthDate"), value: [.var(v)])
    }
    
    /// birthPlace: The place where the person was born.
    func schemaBirthPlace(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("birthPlace"), value: [.varOrTerm(.term(v))])
    }
    
    /// birthPlace: The place where the person was born.
    func schemaBirthPlace(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("birthPlace"), value: [.var(v)])
    }
    
    /// familyName: Family name. In the U.S., the last name of a Person.
    func schemaFamilyName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("familyName"), value: [.varOrTerm(.term(v))])
    }
    
    /// familyName: Family name. In the U.S., the last name of a Person.
    func schemaFamilyName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("familyName"), value: [.var(v)])
    }
    
    /// gender: Gender of something, typically a [[Person]], but possibly also fictional characters, animals, etc. While https://schema.org/Male and https://schema.org/Female may be used, text strings are also acceptable for people who do not identify as a binary gender. The [[gender]] property can also be used in an extended sense to cover e.g. the gender of sports teams. As with the gender of individuals, we do not try to enumerate all possibilities. A mixed-gender [[SportsTeam]] can be indicated with a text value of \"Mixed\".
    func schemaGender(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("gender"), value: [.varOrTerm(.term(v))])
    }
    
    /// gender: Gender of something, typically a [[Person]], but possibly also fictional characters, animals, etc. While https://schema.org/Male and https://schema.org/Female may be used, text strings are also acceptable for people who do not identify as a binary gender. The [[gender]] property can also be used in an extended sense to cover e.g. the gender of sports teams. As with the gender of individuals, we do not try to enumerate all possibilities. A mixed-gender [[SportsTeam]] can be indicated with a text value of \"Mixed\".
    func schemaGender(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("gender"), value: [.var(v)])
    }
    
    /// givenName: Given name. In the U.S., the first name of a Person.
    func schemaGivenName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("givenName"), value: [.varOrTerm(.term(v))])
    }
    
    /// givenName: Given name. In the U.S., the first name of a Person.
    func schemaGivenName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("givenName"), value: [.var(v)])
    }
    
    /// height: The height of the item.
    func schemaHeight(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("height"), value: [.varOrTerm(.term(v))])
    }
    
    /// height: The height of the item.
    func schemaHeight(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("height"), value: [.var(v)])
    }
    
    /// memberOf: An Organization (or ProgramMembership) to which this Person or Organization belongs.
    func schemaMemberOf(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("memberOf"), value: [.varOrTerm(.term(v))])
    }
    
    /// memberOf: An Organization (or ProgramMembership) to which this Person or Organization belongs.
    func schemaMemberOf(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("memberOf"), value: [.var(v)])
    }
    
    /// name: The name of the item.
    func schemaName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.varOrTerm(.term(v))])
    }
    
    /// name: The name of the item.
    func schemaName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.var(v)])
    }
    
    /// position: The position of an item in a series or sequence of items.
    func schemaPosition(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("position"), value: [.varOrTerm(.term(v))])
    }
    
    /// position: The position of an item in a series or sequence of items.
    func schemaPosition(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("position"), value: [.var(v)])
    }
    
    /// weight: The weight of the product or person.
    func schemaWeight(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("weight"), value: [.varOrTerm(.term(v))])
    }
    
    /// weight: The weight of the product or person.
    func schemaWeight(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("weight"), value: [.var(v)])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// label: A human-readable name for the subject.
    func rdfsLabel(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfsSchema.verb("label"), value: [.varOrTerm(.term(v))])
    }
    
    /// label: A human-readable name for the subject.
    func rdfsLabel(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfsSchema.verb("label"), value: [.var(v)])
    }
    
    /// age: The age in years of some agent.
    func foafAge(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: FoafSchema.verb("age"), value: [.varOrTerm(.term(v))])
    }
    
    /// age: The age in years of some agent.
    func foafAge(is v: Var) -> TripleBuilder<State> {
        return appended(verb: FoafSchema.verb("age"), value: [.var(v)])
    }
    
    /// 血液型: 血液型を表すプロパティ
    func imasBloodType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("BloodType"), value: [.varOrTerm(.term(v))])
    }
    
    /// 血液型: 血液型を表すプロパティ
    func imasBloodType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("BloodType"), value: [.var(v)])
    }
    
    /// 胸囲: 胸囲を表すプロパティ
    func imasBust(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Bust"), value: [.varOrTerm(.term(v))])
    }
    
    /// 胸囲: 胸囲を表すプロパティ
    func imasBust(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Bust"), value: [.var(v)])
    }
    
    /// イメージカラー: イメージカラーを表すプロパティ
    func imasColor(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Color"), value: [.varOrTerm(.term(v))])
    }
    
    /// イメージカラー: イメージカラーを表すプロパティ
    func imasColor(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Color"), value: [.var(v)])
    }
    
    /// 星座: 星座を表すプロパティ
    func imasConstellation(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Constellation"), value: [.varOrTerm(.term(v))])
    }
    
    /// 星座: 星座を表すプロパティ
    func imasConstellation(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Constellation"), value: [.var(v)])
    }
    
    /// 好きなもの: 好きなものを表すプロパティ
    func imasFavorite(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Favorite"), value: [.varOrTerm(.term(v))])
    }
    
    /// 好きなもの: 好きなものを表すプロパティ
    func imasFavorite(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Favorite"), value: [.var(v)])
    }
    
    /// 利き手: 利き手を表すプロパティ
    func imasHandedness(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Handedness"), value: [.varOrTerm(.term(v))])
    }
    
    /// 利き手: 利き手を表すプロパティ
    func imasHandedness(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Handedness"), value: [.var(v)])
    }
    
    /// 臀囲: 臀囲(尻囲)を表すプロパティ
    func imasHip(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hip"), value: [.varOrTerm(.term(v))])
    }
    
    /// 臀囲: 臀囲(尻囲)を表すプロパティ
    func imasHip(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hip"), value: [.var(v)])
    }
    
    /// 趣味: 趣味を表すプロパティ
    func imasHobby(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hobby"), value: [.varOrTerm(.term(v))])
    }
    
    /// 趣味: 趣味を表すプロパティ
    func imasHobby(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Hobby"), value: [.var(v)])
    }
    
    /// 靴のサイズ: 靴のサイズを表すプロパティ
    func imasShoeSize(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("ShoeSize"), value: [.varOrTerm(.term(v))])
    }
    
    /// 靴のサイズ: 靴のサイズを表すプロパティ
    func imasShoeSize(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("ShoeSize"), value: [.var(v)])
    }
    
    /// 特技: 特技を表すプロパティ
    func imasTalent(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Talent"), value: [.varOrTerm(.term(v))])
    }
    
    /// 特技: 特技を表すプロパティ
    func imasTalent(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Talent"), value: [.var(v)])
    }
    
    /// タイプ: タイプ(Cu,Co,Pa)を表すプロパティ
    func imasType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Type"), value: [.varOrTerm(.term(v))])
    }
    
    /// タイプ: タイプ(Cu,Co,Pa)を表すプロパティ
    func imasType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Type"), value: [.var(v)])
    }
    
    /// 腹囲: 腹囲を表すプロパティ
    func imasWaist(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Waist"), value: [.varOrTerm(.term(v))])
    }
    
    /// 腹囲: 腹囲を表すプロパティ
    func imasWaist(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Waist"), value: [.var(v)])
    }
    
    /// 担当声優: 担当声優を表すプロパティ
    func imasCv(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("cv"), value: [.varOrTerm(.term(v))])
    }
    
    /// 担当声優: 担当声優を表すプロパティ
    func imasCv(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("cv"), value: [.var(v)])
    }
    
    /// 姓よみがな: 姓のよみがなを表すプロパティ
    func imasFamilyNameKana(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("familyNameKana"), value: [.varOrTerm(.term(v))])
    }
    
    /// 姓よみがな: 姓のよみがなを表すプロパティ
    func imasFamilyNameKana(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("familyNameKana"), value: [.var(v)])
    }
    
    /// 名よみがな: 名のよみがなを表すプロパティ
    func imasGivenNameKana(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("givenNameKana"), value: [.varOrTerm(.term(v))])
    }
    
    /// 名よみがな: 名のよみがなを表すプロパティ
    func imasGivenNameKana(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("givenNameKana"), value: [.var(v)])
    }
    
    /// 名前よみがな: 名前のよみがなを表すプロパティ
    func imasNameKana(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("nameKana"), value: [.varOrTerm(.term(v))])
    }
    
    /// 名前よみがな: 名前のよみがなを表すプロパティ
    func imasNameKana(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("nameKana"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasXenoglossiaIdol {
    
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasXenoglossiaCharacter {
    
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasUnit {
    /// alternateName: An alias for the item.
    func schemaAlternateName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("alternateName"), value: [.varOrTerm(.term(v))])
    }
    
    /// alternateName: An alias for the item.
    func schemaAlternateName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("alternateName"), value: [.var(v)])
    }
    
    /// description: A description of the item.
    func schemaDescription(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("description"), value: [.varOrTerm(.term(v))])
    }
    
    /// description: A description of the item.
    func schemaDescription(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("description"), value: [.var(v)])
    }
    
    /// member: A member of an Organization or a ProgramMembership. Organizations can be members of organizations; ProgramMembership is typically for individuals.
    func schemaMember(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("member"), value: [.varOrTerm(.term(v))])
    }
    
    /// member: A member of an Organization or a ProgramMembership. Organizations can be members of organizations; ProgramMembership is typically for individuals.
    func schemaMember(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("member"), value: [.var(v)])
    }
    
    /// name: The name of the item.
    func schemaName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.varOrTerm(.term(v))])
    }
    
    /// name: The name of the item.
    func schemaName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.var(v)])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// イメージカラー: イメージカラーを表すプロパティ
    func imasColor(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Color"), value: [.varOrTerm(.term(v))])
    }
    
    /// イメージカラー: イメージカラーを表すプロパティ
    func imasColor(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Color"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasEvent {
    /// actor: An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
    func schemaActor(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("actor"), value: [.varOrTerm(.term(v))])
    }
    
    /// actor: An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
    func schemaActor(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("actor"), value: [.var(v)])
    }
    
    /// name: The name of the item.
    func schemaName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.varOrTerm(.term(v))])
    }
    
    /// name: The name of the item.
    func schemaName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.var(v)])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasFacility {
    
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasProduction {
    
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasCinderellaRankingResult {
    /// member: A member of an Organization or a ProgramMembership. Organizations can be members of organizations; ProgramMembership is typically for individuals.
    func schemaMember(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("member"), value: [.varOrTerm(.term(v))])
    }
    
    /// member: A member of an Organization or a ProgramMembership. Organizations can be members of organizations; ProgramMembership is typically for individuals.
    func schemaMember(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("member"), value: [.var(v)])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// 得票数: 得票数を表すプロパティ
    func imasVoteNumber(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("VoteNumber"), value: [.varOrTerm(.term(v))])
    }
    
    /// 得票数: 得票数を表すプロパティ
    func imasVoteNumber(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("VoteNumber"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasCinderellaVoiceIdolAudition {
    /// member: A member of an Organization or a ProgramMembership. Organizations can be members of organizations; ProgramMembership is typically for individuals.
    func schemaMember(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("member"), value: [.varOrTerm(.term(v))])
    }
    
    /// member: A member of an Organization or a ProgramMembership. Organizations can be members of organizations; ProgramMembership is typically for individuals.
    func schemaMember(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("member"), value: [.var(v)])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// 得票数: 得票数を表すプロパティ
    func imasVoteNumber(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("VoteNumber"), value: [.varOrTerm(.term(v))])
    }
    
    /// 得票数: 得票数を表すプロパティ
    func imasVoteNumber(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("VoteNumber"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasLive {
    /// actor: An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
    func schemaActor(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("actor"), value: [.varOrTerm(.term(v))])
    }
    
    /// actor: An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
    func schemaActor(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("actor"), value: [.var(v)])
    }
    
    /// endDate: The end date and time of the item (in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601)).
    func schemaEndDate(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("endDate"), value: [.varOrTerm(.term(v))])
    }
    
    /// endDate: The end date and time of the item (in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601)).
    func schemaEndDate(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("endDate"), value: [.var(v)])
    }
    
    /// eventStatus: An eventStatus of an event represents its status; particularly useful when an event is cancelled or rescheduled.
    func schemaEventStatus(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("eventStatus"), value: [.varOrTerm(.term(v))])
    }
    
    /// eventStatus: An eventStatus of an event represents its status; particularly useful when an event is cancelled or rescheduled.
    func schemaEventStatus(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("eventStatus"), value: [.var(v)])
    }
    
    /// location: The location of, for example, where an event is happening, where an organization is located, or where an action takes place.
    func schemaLocation(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("location"), value: [.varOrTerm(.term(v))])
    }
    
    /// location: The location of, for example, where an event is happening, where an organization is located, or where an action takes place.
    func schemaLocation(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("location"), value: [.var(v)])
    }
    
    /// name: The name of the item.
    func schemaName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.varOrTerm(.term(v))])
    }
    
    /// name: The name of the item.
    func schemaName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.var(v)])
    }
    
    /// startDate: The start date and time of the item (in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601)).
    func schemaStartDate(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("startDate"), value: [.varOrTerm(.term(v))])
    }
    
    /// startDate: The start date and time of the item (in [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601)).
    func schemaStartDate(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("startDate"), value: [.var(v)])
    }
    
    /// url: URL of the item.
    func schemaUrl(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("url"), value: [.varOrTerm(.term(v))])
    }
    
    /// url: URL of the item.
    func schemaUrl(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("url"), value: [.var(v)])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// 披露した曲数: 披露した曲数を表すプロパティ
    func imasNumPerformance(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("NumPerformance"), value: [.varOrTerm(.term(v))])
    }
    
    /// 披露した曲数: 披露した曲数を表すプロパティ
    func imasNumPerformance(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("NumPerformance"), value: [.var(v)])
    }
    
    /// 披露したアンコール曲数: 披露したアンコール曲数を表すプロパティ
    func imasNumPerformanceEncore(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("NumPerformanceEncore"), value: [.varOrTerm(.term(v))])
    }
    
    /// 披露したアンコール曲数: 披露したアンコール曲数を表すプロパティ
    func imasNumPerformanceEncore(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("NumPerformanceEncore"), value: [.var(v)])
    }
    
    /// 披露した曲: 披露した曲を表すプロパティ
    func imasPerformance(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Performance"), value: [.varOrTerm(.term(v))])
    }
    
    /// 披露した曲: 披露した曲を表すプロパティ
    func imasPerformance(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Performance"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasSetlistNumber {
    /// actor: An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
    func schemaActor(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("actor"), value: [.varOrTerm(.term(v))])
    }
    
    /// actor: An actor, e.g. in tv, radio, movie, video games etc., or in an event. Actors can be associated with individual items or with a series, episode, clip.
    func schemaActor(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("actor"), value: [.var(v)])
    }
    
    /// name: The name of the item.
    func schemaName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.varOrTerm(.term(v))])
    }
    
    /// name: The name of the item.
    func schemaName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.var(v)])
    }
    
    /// performer: A performer at the event&#x2014;for example, a presenter, musician, musical group or actor.
    func schemaPerformer(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("performer"), value: [.varOrTerm(.term(v))])
    }
    
    /// performer: A performer at the event&#x2014;for example, a presenter, musician, musical group or actor.
    func schemaPerformer(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("performer"), value: [.var(v)])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// セットリスト内番号: セットリスト内番号を表すプロパティ
    func imasTuneNumber(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("TuneNumber"), value: [.varOrTerm(.term(v))])
    }
    
    /// セットリスト内番号: セットリスト内番号を表すプロパティ
    func imasTuneNumber(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("TuneNumber"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasScriptText {
    /// text: The textual content of this CreativeWork.
    func schemaText(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("text"), value: [.varOrTerm(.term(v))])
    }
    
    /// text: The textual content of this CreativeWork.
    func schemaText(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("text"), value: [.var(v)])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// セリフテキスト番号: セリフテキスト番号を表すプロパティ
    func imasScriptNumber(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("ScriptNumber"), value: [.varOrTerm(.term(v))])
    }
    
    /// セリフテキスト番号: セリフテキスト番号を表すプロパティ
    func imasScriptNumber(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("ScriptNumber"), value: [.var(v)])
    }
    
    /// 出どころ: 出どころを表すプロパティ
    func imasSource(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Source"), value: [.varOrTerm(.term(v))])
    }
    
    /// 出どころ: 出どころを表すプロパティ
    func imasSource(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Source"), value: [.var(v)])
    }
    
    /// 発言者表記: 発言者表記を表すプロパティ
    func imasSpeakerLabel(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("SpeakerLabel"), value: [.varOrTerm(.term(v))])
    }
    
    /// 発言者表記: 発言者表記を表すプロパティ
    func imasSpeakerLabel(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("SpeakerLabel"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasCommunication {
    /// location: The location of, for example, where an event is happening, where an organization is located, or where an action takes place.
    func schemaLocation(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("location"), value: [.varOrTerm(.term(v))])
    }
    
    /// location: The location of, for example, where an event is happening, where an organization is located, or where an action takes place.
    func schemaLocation(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("location"), value: [.var(v)])
    }
    
    /// participant: Other co-agents that participated in the action indirectly. e.g. John wrote a book with *Steve*.
    func schemaParticipant(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("participant"), value: [.varOrTerm(.term(v))])
    }
    
    /// participant: Other co-agents that participated in the action indirectly. e.g. John wrote a book with *Steve*.
    func schemaParticipant(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("participant"), value: [.var(v)])
    }
    
    /// title: The title of the job.
    func schemaTitle(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("title"), value: [.varOrTerm(.term(v))])
    }
    
    /// title: The title of the job.
    func schemaTitle(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("title"), value: [.var(v)])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// セリフテキスト: セリフテキストを表すプロパティ
    func imasScript(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Script"), value: [.varOrTerm(.term(v))])
    }
    
    /// セリフテキスト: セリフテキストを表すプロパティ
    func imasScript(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Script"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasCallName {
    /// type: The subject is an instance of a class.
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// 呼び方: 呼び方を表すプロパティ
    func imasCalled(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Called"), value: [.varOrTerm(.term(v))])
    }
    
    /// 呼び方: 呼び方を表すプロパティ
    func imasCalled(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Called"), value: [.var(v)])
    }
    
    /// あて先: あて先を表すプロパティ
    func imasDestination(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Destination"), value: [.varOrTerm(.term(v))])
    }
    
    /// あて先: あて先を表すプロパティ
    func imasDestination(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Destination"), value: [.var(v)])
    }
    
    /// 出どころ: 出どころを表すプロパティ
    func imasSource(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Source"), value: [.varOrTerm(.term(v))])
    }
    
    /// 出どころ: 出どころを表すプロパティ
    func imasSource(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Source"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasIntroduction {
    /// description: A description of the item.
    func schemaDescription(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("description"), value: [.varOrTerm(.term(v))])
    }
    
    /// description: A description of the item.
    func schemaDescription(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("description"), value: [.var(v)])
    }
    
    /// name: The name of the item.
    func schemaName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.varOrTerm(.term(v))])
    }
    
    /// name: The name of the item.
    func schemaName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.var(v)])
    }
    
    /// releaseDate: The release date of a product or product model. This can be used to distinguish the exact variant of a product.
    func schemaReleaseDate(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("releaseDate"), value: [.varOrTerm(.term(v))])
    }
    
    /// releaseDate: The release date of a product or product model. This can be used to distinguish the exact variant of a product.
    func schemaReleaseDate(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("releaseDate"), value: [.var(v)])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// あて先: あて先を表すプロパティ
    func imasDestination(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Destination"), value: [.varOrTerm(.term(v))])
    }
    
    /// あて先: あて先を表すプロパティ
    func imasDestination(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Destination"), value: [.var(v)])
    }
    
    /// 出どころ: 出どころを表すプロパティ
    func imasSource(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Source"), value: [.varOrTerm(.term(v))])
    }
    
    /// 出どころ: 出どころを表すプロパティ
    func imasSource(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Source"), value: [.var(v)])
    }
}

public extension TripleBuilder where State: TripleBuilderStateRDFTypeBoundType, State.RDFType == ImasClothes {
    /// description: A description of the item.
    func schemaDescription(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("description"), value: [.varOrTerm(.term(v))])
    }
    
    /// description: A description of the item.
    func schemaDescription(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("description"), value: [.var(v)])
    }
    
    /// name: The name of the item.
    func schemaName(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.varOrTerm(.term(v))])
    }
    
    /// name: The name of the item.
    func schemaName(is v: Var) -> TripleBuilder<State> {
        return appended(verb: SchemaSchema.verb("name"), value: [.var(v)])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.varOrTerm(.term(v))])
    }
    
    /// type: The subject is an instance of a class.
    func rdfType(is v: Var) -> TripleBuilder<State> {
        return appended(verb: RdfSchema.verb("type"), value: [.var(v)])
    }
    
    /// 所有者: 所有者を表すプロパティ
    func imasWhose(is v: GraphTerm) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Whose"), value: [.varOrTerm(.term(v))])
    }
    
    /// 所有者: 所有者を表すプロパティ
    func imasWhose(is v: Var) -> TripleBuilder<State> {
        return appended(verb: ImasSchema.verb("Whose"), value: [.var(v)])
    }
}