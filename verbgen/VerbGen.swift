import SwiftSparql
import struct Foundation.URL
import ReactiveSwift

enum _RdfSchema: SwiftSparql.IRIBaseProvider {
    public static var base: IRIRef {return IRIRef(value: "http://www.w3.org/1999/02/22-rdf-syntax-ns#")}
}

struct VerbGen {
    var turtleDoc: TurtleDoc
    var references: [TurtleDoc]
    var endpoint: URL

    init(target: TurtleDoc, references: [TurtleDoc], endpoint: URL) {
        self.turtleDoc = target
        self.references = references
        self.endpoint = endpoint
    }
    
    func gen(additionalDirectives: [IRIBaseProvider] = [], completion: @escaping (String) -> Void) {
        let subjects = turtleDoc.triples.compactMap {SubjectDescription($0, directives: turtleDoc.directives)}
        
        let directives: [IRIBaseProvider] = turtleDoc.statements.compactMap {
            switch $0 {
            case .directive(.prefixID(let name, let iri)): return IRIBaseProvider(name: name, iri: iri)
            case .directive, .triple: return nil
            }
        } + additionalDirectives
        
        let classes = subjects.filter {
            $0.a.contains {
                switch $0 {
                case .prefixedName(.ln((PNameNS(value: "rdfs"), "Class"))): return true
                case .ref(IRIRef(value: "http://www.w3.org/2000/01/rdf-schema#Class")): return true
                default: return false
                }
            }
        }
        
        let properties = references.map {doc in doc.triples.compactMap {SubjectDescription($0, directives: doc.directives)}}.joined().filter {
            $0.a.contains {
                switch $0 {
                case .prefixedName(.ln((PNameNS(value: "rdf"), "Property"))): return true
                case .ref(IRIRef(value: "http://www.w3.org/1999/02/22-rdf-syntax-ns#Property")): return true
                default: return false
                }
            }
        }
        
        let prologues = directives.map {Prologue.prefix($0.name, $0.iri)}
        
        SignalProducer(classes)
            .flatMap(.concat) { subjectDescription in
                SignalProducer<[VerbQuery.Response], Never> { observer, lifetime in
                    VerbQuery(subjectDescription, endpoint: self.endpoint, prologues: prologues).fetch {
                        observer.send(value: $0)
                        observer.sendCompleted()
                    }
                    }
                    .map {(subjectDescription, $0)}
                    .delay(0.2, on: QueueScheduler.main)
            }
            .on(value: { sd, vs in
                let type: String
                switch sd.subject {
                case .iri(let v): type = Serializer.serialize(v)
                case .blank(let v): type = Serializer.serialize(v)
                case .collection(let v): type = String(describing: v)
                }
                print("\(type) has \(vs.count) verbs")})
            .collect()
            .startWithValues { values in
                let rdfTypeConvertibles = values.compactMap { subjectDescription, _ in
                    RDFTypeConvertible(subjectDescription.subject, directives: directives, prologues: prologues)
                }
                let verbExtensions = values.compactMap { subjectDescription, verbs in
                    TripleBuilderStateRDFTypeBoundType(
                        subject: subjectDescription.subject,
                        verbs: verbs.map {$0.v}.sorted(),
                        directives: directives,
                        properties: properties,
                        prologues: prologues)
                }
                let swiftCodes = ["// generated by verbgen"]
                    + directives.map(SwiftCode.gen)
                    + rdfTypeConvertibles.map(SwiftCode.gen)
                    + verbExtensions.map(SwiftCode.gen)                
                completion(swiftCodes.joined(separator: "\n\n"))
        }
    }
}
